Design for maintainability - Starting

SOLID is an acronym for five software design principles: 

1. Single responsibility principle: One class should have only a single responsibility. 
    Know when to start and build a new class. Have good class scope
2. Open-closed principle: Components (classes, methods, etc.) should be open for extension but closed for modification. 
3. Liskov's substitution principle: Derived types must be completely substitutable for their base types. 
4. Interface segregation principle: Clients should not be forced to depend upon the interfaces they do not use. 
5. Dependency inversion principle: Program to an interface, not to an implementation. 

1. Bad Code
class NetworkService : 
  def __init__(self, name, config):
      self.name = name
      self.config = config 
  
  def set_name (self, name) : 
      self.name = name
  
  def set_config (self, config) : 
      self. config = config 
  def deploy_service (self) :  
    Infrastructure.deploy(self.name, self.config) 
    
1. Good Code

class NetworkService : 
  def __init__(self, name, config):
      self.name = name
      self.config = config 
  
  def set_name (self, name) : 
      self.name = name
  
  def set_config (self, config) : 
      self. config = config 
class NetworkServiceDeployer:
  def deploy_service (self) :  
    Infrastructure.deploy(self.name, self.config) 
    
The Facade pattern allows you to interface with the second class but does not utilize within its code:

class NetworkService : 
  def __init__ (self, name, config) : 
     self.name = name 
     self.config = config
     self.deployer = NetworkServiceDeployer()  # Facade

  def set_name(self, name) : 
    self.name = name 
  def set_config(self, config) :  
    self.config = config 
  def deploy_service(self) : 
    self.deployer.deploy_service(self.service) 


2. Bade Code

class NetworkService : 
  def __init__(self, name, config):
      self.type = type
      self.config = config 
      
class NetworkServiceDeployer:
  def deploy_service (self, service) :  
    if service.type == 'user':
      frastructure.deploy(service.config, '10.100.50.10/24')

2. Good Code

class NetworkService : 
  def __init__(self, name, config):
      self.type = type
      self.config = config 
      
 class NetworkServiceUser(NetworkService:
  def __init__ (self) :  
    super().__init__(self)
      self.segment = '10.100.50.0.24')
      
 class NetworkServiceMgmt(NetworkService):
  def __init__ (self) :  
    super().__init__(self)
      self.segment = '10.200.50.0.24')
  
 class NetworkServiceDeployer:
  def deploy_service (self, service) :  
    Infrastructure.deploy(service.config, '10.10.10.10/24')
    
In this case, you add a segment parameter that converts the if clause from the previous example to an extended class parameter. 

Note the super() call. This is a function call that has access to the original nonextended class, NetworkService, its parameters, and methods.
By using it, you can initialize the original class and then append extra parameters to each extended class.
